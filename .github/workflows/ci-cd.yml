# This workflow handles the complete CI/CD pipeline for your application
# It includes building, testing, and deploying your application to your server

name: CI/CD Pipeline

# Define when this workflow should run
on:
  # Run on pushes to main branch
  push:
    branches:
      - main
  # Run on pull requests targeting main branch
  pull_request:
    branches:
      - main

# Environment variables used throughout the workflow
env:
  NODE_VERSION: '20'
  DEPLOY_PATH: '/app'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    # Define environment variables, using GitHub secrets for sensitive data
    env:
      SERVER_IP: ${{ secrets.SERVER_IP }}
      SERVER_USER: ${{ secrets.SERVER_USER }}
      DEPLOY_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
      RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
      POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      POSTGRES_DB: ${{ secrets.POSTGRES_DB }}

    steps:
      # Step 1: Check out the repository code
      - name: Checkout code
        uses: actions/checkout@v3

      # Step 2: Set up Node.js environment
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      # Step 3: Install project dependencies
      - name: Install dependencies
        run: npm ci
      
      # Step 4: Build the application
      - name: Build
        run: |
          npm run build
          ls -la dist/

      # Step 5: Create necessary configuration files
      - name: Create configuration files
        run: |
          # Create environment file
          cat << EOF > .env
          # Database Configuration
          POSTGRES_USER=${POSTGRES_USER}
          POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
          POSTGRES_DB=${POSTGRES_DB}
          DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@localhost:5432/${POSTGRES_DB}
          NODE_ENV=production
          PORT=3000
          EOF

          # Create Nginx configuration
          cat << 'EOF' > nginx.conf
          user nginx;
          worker_processes auto;
          error_log /var/log/nginx/error.log notice;
          pid /var/run/nginx.pid;

          events {
              worker_connections 1024;
          }

          http {
              include /etc/nginx/mime.types;
              default_type application/octet-stream;

              log_format detailed '$remote_addr - $remote_user [$time_local] '
                               '"$request" $status $body_bytes_sent '
                               '"$http_referer" "$http_user_agent" '
                               'file: "$request_filename" root: "$document_root"';

              access_log /var/log/nginx/access.log detailed;
              error_log /var/log/nginx/error.log debug;

              sendfile on;
              tcp_nopush on;
              tcp_nodelay on;
              keepalive_timeout 65;
              types_hash_max_size 2048;

              server {
                  listen 80;
                  server_name localhost;
                  
                  root /usr/share/nginx/html;
                  index index.html;

                  location / {
                      try_files $uri $uri/ /index.html;
                      
                      add_header X-Frame-Options "SAMEORIGIN" always;
                      add_header X-XSS-Protection "1; mode=block" always;
                      add_header X-Content-Type-Options "nosniff" always;
                      add_header Referrer-Policy "no-referrer-when-unsafe" always;
                      add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;
                  }

                  location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
                      expires 1y;
                      add_header Cache-Control "public, no-transform";
                  }

                  error_page 404 /404.html;
                  error_page 500 502 503 504 /50x.html;
              }
          }
          EOF

      # Step 6: Setup SSH for deployment
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts

      # Step 7: Deploy application
      - name: Deploy
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: |
          # Create deployment script
          cat << 'EOSSH' > deploy.sh
          #!/bin/bash
          set -e

          # Color output for better readability
          RED='\033[0;31m'
          GREEN='\033[0;32m'
          YELLOW='\033[1;33m'
          NC='\033[0m'

          log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
          log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
          log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

          # Function to check Docker permissions
          setup_docker() {
            log_info "Setting up Docker permissions..."
            if ! groups | grep -q docker; then
              sudo usermod -aG docker $USER
              log_warn "Added user to docker group. Using sudo for this session."
              return 1
            fi
            return 0
          }

          # Function to run Docker commands
          docker_cmd() {
            if setup_docker; then
              docker "$@"
            else
              sudo docker "$@"
            fi
          }

          # Function to run Docker Compose commands
          docker_compose_cmd() {
            if setup_docker; then
              docker-compose "$@"
            else
              sudo docker-compose "$@"
            fi
          }

          # Deploy application
          deploy_app() {
            cd /app

            log_info "Stopping existing containers..."
            docker_compose_cmd down -v || true
            docker_cmd system prune -af --force || true

            log_info "Starting services..."
            if ! docker_compose_cmd up -d --build --force-recreate; then
              log_error "Failed to start services"
              docker_compose_cmd logs
              exit 1
            fi

            log_info "Setting up web files..."
            docker exec web_app /bin/sh -c "
              chown -R nginx:nginx /usr/share/nginx/html
              find /usr/share/nginx/html -type d -exec chmod 755 {} \;
              find /usr/share/nginx/html -type f -exec chmod 644 {} \;
            "

            log_info "Verifying deployment..."
            sleep 10
            
            if ! curl -sSf http://localhost:80 > /dev/null; then
              log_error "Deployment verification failed"
              docker_compose_cmd logs web_app
              exit 1
            fi

            log_info "Deployment completed successfully"
          }

          # Main execution
          deploy_app
          EOSSH

          # Make deployment script executable
          chmod +x deploy.sh

          # Copy files to server
          echo "Copying deployment files..."
          ssh -i ~/.ssh/deploy_key ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "mkdir -p ${{ env.DEPLOY_PATH }}"
          
          scp -i ~/.ssh/deploy_key \
            docker-compose.yml Dockerfile nginx.conf .env deploy.sh \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }}:${{ env.DEPLOY_PATH }}/

          # Copy application files
          echo "Copying application files..."
          scp -i ~/.ssh/deploy_key -r \
            dist/* \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }}:${{ env.DEPLOY_PATH }}/dist/

          # Execute deployment
          echo "Executing deployment..."
          ssh -i ~/.ssh/deploy_key ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} \
            "cd ${{ env.DEPLOY_PATH }} && bash deploy.sh"

      # Step 8: Send deployment notification
      - name: Send Deployment Status Email
        if: always()
        run: |
          if [ -n "$RESEND_API_KEY" ]; then
            DEPLOY_STATUS="${{ job.status }}"
            DEPLOY_TIME=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
            
            curl -X POST \
              -H "Authorization: Bearer $RESEND_API_KEY" \
              -H "Content-Type: application/json" \
              https://api.resend.com/emails \
              -d '{
                "from": "notifications@hassan-adam.com",
                "to": "haskhr@hotmail.com",
                "subject": "Deployment Status: '"$DEPLOY_STATUS"'",
                "html": "
                  <h2>Deployment Status: '"$DEPLOY_STATUS"'</h2>
                  <p><strong>Repository:</strong> '"${{ github.repository }}"'</p>
                  <p><strong>Branch:</strong> '"${GITHUB_REF#refs/heads/}"'</p>
                  <p><strong>Commit:</strong> '"${{ github.sha }}"'</p>
                  <p><strong>Triggered by:</strong> '"${{ github.actor }}"'</p>
                  <p><strong>Deployment Time:</strong> '"$DEPLOY_TIME"'</p>
                "
              }'
          fi

      # Step 9: Cleanup
      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
          rm -f deploy.sh
