name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    env:
      SERVER_IP: ${{ secrets.SERVER_IP }}
      SERVER_USER: ${{ secrets.SERVER_USER }}
      DEPLOY_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
      RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
        
      # Removed the test step since there are no tests configured
      
      - name: Build
        run: |
          npm run build
          ls -la dist/
          
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts

      - name: Test SSH Connection
        run: |
          if ! ssh -i ~/.ssh/deploy_key -o ConnectTimeout=10 -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} 'echo "SSH connection successful"'; then
            echo "Failed to establish SSH connection"
            exit 1
          fi

      - name: Deploy
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: |
          # Create deployment script
          cat << 'EOF' > deploy.sh
          #!/bin/bash
          set -e

          echo "Starting deployment process..."
          
          # Function to check if port 80 is in use
          check_port_80() {
            if sudo lsof -i :80 >/dev/null 2>&1; then
              echo "Port 80 is in use. Attempting to free it..."
              sudo lsof -t -i:80 | xargs -r sudo kill -9
              sleep 5
            fi
          }

          # Function to wait for container health
          wait_for_container() {
            local container_name=$1
            local max_attempts=30
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              if docker inspect --format='{{.State.Health.Status}}' $container_name 2>/dev/null | grep -q "healthy"; then
                echo "$container_name is healthy"
                return 0
              fi
              echo "Waiting for $container_name to be healthy (attempt $attempt/$max_attempts)..."
              sleep 10
              attempt=$((attempt + 1))
            done
            
            echo "$container_name failed to become healthy"
            docker logs $container_name
            return 1
          }

          cd /app

          # Backup current deployment
          if [ -d "dist" ]; then
            mv dist dist_backup
          fi

          # Clean up Docker resources
          echo "Cleaning up Docker resources..."
          docker-compose down -v || true
          docker system prune -af --volumes || true

          # Check and free port 80
          check_port_80

          # Start containers
          echo "Starting containers..."
          docker-compose up -d --build --force-recreate

          # Wait for web_app container to be healthy
          if ! wait_for_container "web_app"; then
            echo "Deployment failed - rolling back..."
            docker-compose down
            [ -d "dist_backup" ] && mv dist_backup dist
            exit 1
          fi

          # Cleanup backup if deployment successful
          [ -d "dist_backup" ] && rm -rf dist_backup

          echo "Deployment completed successfully"
          EOF

          # Copy deployment files
          echo "Copying deployment files..."
          scp -i ~/.ssh/deploy_key \
            docker-compose.yml Dockerfile nginx.conf .env deploy.sh \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }}:/app/

          # Copy dist directory
          echo "Copying dist directory..."
          ssh -i ~/.ssh/deploy_key ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} 'mkdir -p /app/dist'
          scp -i ~/.ssh/deploy_key -r dist/* \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }}:/app/dist/

          # Execute deployment
          ssh -i ~/.ssh/deploy_key ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} '
            cd /app && 
            chmod +x deploy.sh && 
            ./deploy.sh
          '

      - name: Send Deployment Status Email
        if: always()
        run: |
          if [ -n "$RESEND_API_KEY" ]; then
            DEPLOY_STATUS="${{ job.status }}"
            DEPLOY_TIME=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
            
            curl -X POST \
              -H "Authorization: Bearer $RESEND_API_KEY" \
              -H "Content-Type: application/json" \
              https://api.resend.com/emails \
              -d '{
                "from": "notifications@hassan-adam.com",
                "to": "haskhr@hotmail.com",
                "subject": "Deployment Status: '"$DEPLOY_STATUS"'",
                "html": "
                  <h2>Deployment Status: '"$DEPLOY_STATUS"'</h2>
                  <p><strong>Repository:</strong> '"${{ github.repository }}"'</p>
                  <p><strong>Branch:</strong> '"${GITHUB_REF#refs/heads/}"'</p>
                  <p><strong>Commit:</strong> '"${{ github.sha }}"'</p>
                  <p><strong>Triggered by:</strong> '"${{ github.actor }}"'</p>
                  <p><strong>Deployment Time:</strong> '"$DEPLOY_TIME"'</p>
                "
              }'
          else
            echo "RESEND_API_KEY not set, skipping email notification"
          fi

      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
          ssh -i ~/.ssh/deploy_key ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} '
            cd /app
            docker-compose down -v || true
            docker system prune -af || true
          ' || true
