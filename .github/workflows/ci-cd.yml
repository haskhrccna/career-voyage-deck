name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    env:
      SERVER_IP: ${{ secrets.SERVER_IP }}
      SERVER_USER: ${{ secrets.SERVER_USER }}
      DEPLOY_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
      RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
      POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      POSTGRES_DB: ${{ secrets.POSTGRES_DB }}

    steps:
      # ... (previous steps remain the same) ...

      - name: Create Environment File
        run: |
          cat << EOF > .env
          # Database Configuration
          POSTGRES_USER=${POSTGRES_USER}
          POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
          POSTGRES_DB=${POSTGRES_DB}
          
          # Database Connection URL
          DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@localhost:5432/${POSTGRES_DB}
          
          # Application Configuration
          NODE_ENV=production
          PORT=3000
          EOF
          
          # Show the generated .env file without sensitive values
          echo "Generated .env file (with secrets hidden):"
          cat .env | sed 's/=.*/=****/'

      - name: Deploy
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        run: |
          # Create deployment script with environment variable handling
          cat << 'EOSSH' > deploy_remote.sh
          cd /app
          
          # Ensure proper permissions
          sudo chown -R $USER:$USER .
          chmod 755 .
          
          # Make environment file readable only by owner
          chmod 600 .env
          
          # Validate environment variables
          if [ ! -s .env ]; then
            echo "Error: .env file is empty or missing"
            exit 1
          fi
          
          # Source environment variables
          set -a
          source .env
          set +a
          
          # Validate required database variables
          required_vars=("POSTGRES_USER" "POSTGRES_PASSWORD" "POSTGRES_DB")
          for var in "${required_vars[@]}"; do
            if [ -z "${!var}" ]; then
              echo "Error: $var is not set"
              exit 1
            fi
          done
          
          # Stop and remove existing containers
          docker-compose down -v || true
          docker system prune -af || true
          
          # Start containers with proper error handling
          if ! docker-compose up -d --build --force-recreate; then
            echo "Failed to start containers"
            docker-compose logs
            exit 1
          fi
          
          # Wait for PostgreSQL to be ready
          echo "Waiting for PostgreSQL to be ready..."
          max_attempts=30
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            if docker-compose exec -T db pg_isready; then
              echo "PostgreSQL is ready!"
              break
            fi
            
            echo "Attempt $attempt/$max_attempts: PostgreSQL is not ready yet..."
            sleep 2
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "Error: PostgreSQL failed to become ready"
            docker-compose logs db
            exit 1
          fi
          
          echo "Deployment completed successfully"
          EOSSH
          
          # Deploy files and execute script
          scp -i ~/.ssh/deploy_key \
            docker-compose.yml Dockerfile nginx.conf .env deploy_remote.sh \
            ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }}:/app/

          ssh -i ~/.ssh/deploy_key ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }} "cd /app && bash deploy_remote.sh"

      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
          rm -f setup_server.sh
          rm -f deploy_remote.sh
